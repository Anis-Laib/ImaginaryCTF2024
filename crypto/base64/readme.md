## Challenge Description
-   Name: base64
-   Points: 100
-   Description:
	"yet another base64 decoding challenge"
- Attachements: [https://cybersharing.net/s/8c2a3e4e78a0161f](https://cybersharing.net/s/8c2a3e4e78a0161f)
## Solution
In this challenge we are provided with the source code of the encryption which looks like a base64 base conversion and an output file
while analysing the source code I found that it does two things:
- Reading and Converting the Flag
```python
from Crypto.Util.number import bytes_to_long

flag = open("flag.txt", "rb").read()  # Read the flag from a file in binary mode
flag_int = bytes_to_long(flag)  # Convert the binary data to a long integer
```
- Decomposing the Integer
```python
q = 64
secret_key = []
while flag_int:
   secret_key.append(flag_int % q)
   flag_int //= q
```

Mathematically, this can be expressed as repeatedly finding the remainder and quotient when dividing by 64:
```math
\text{flag\_int} = a_0 + a_1 \cdot q + a_2 \cdot q^2 + \ldots + a_n \cdot q^n
```

where ($a_i$) are the digits of `flag_int` in base 64. The `while` loop is essentially performing:
```math
a_i = \text{flag\_int} \% q
```
```math
\text{flag\_int} = \left\lfloor \frac{\text{flag\_int}}{q} \right\rfloor
```
This loop continues until `flag_int` becomes zero, collecting all the remainders in `secret_key`.

As I said we were also given an out.txt file containing a secret key
```python
secret_key = [10, 52, 23, 14, 52, 16, 3, 14, 37, 37, 3, 25, 50, 32, 19, 14, 48, 32, 35, 13, 54, 12, 35, 12, 31, 29, 7, 29, 38, 61, 37, 27, 47, 5, 51, 28, 50, 13, 35, 29, 46, 1, 51, 24, 31, 21, 54, 28, 52, 8, 54, 30, 38, 17, 55, 24, 41, 1]
```
This is the `secret_key` list that was generated by the challenge code.

So as a solution I tried reconstructing the integer:
```python
q = 64
flag_int = 0
for i in reversed(secret_key):
   flag_int = flag_int * q + i
```
Mathematically, this is performing the inverse operation of the decomposition:
```math
\text{flag\_int} = \sum_{i=0}^{n} a_i \cdot q^i
```
Starting from the least significant digit and building up to the most significant digit.
And then I convert the long integer into bytes and go the flag
```python
from Crypto.Util.number import long_to_bytes

flag = long_to_bytes(flag_int)
```

Here is the full solution code:
```python
[from Crypto.Util.number import long_to_bytes

flag = long_to_bytes(flag_int)](<from Crypto.Util.number import long_to_bytes

secret_key = [10, 52, 23, 14, 52, 16, 3, 14, 37, 37, 3, 25, 50, 32, 19, 14, 48, 32, 35, 13, 54, 12, 35, 12, 31, 29, 7, 29, 38, 61, 37, 27, 47, 5, 51, 28, 50, 13, 35, 29, 46, 1, 51, 24, 31, 21, 54, 28, 52, 8, 54, 30, 38, 17, 55, 24, 41, 1]

q = 64

flag_int = 0
for i in reversed(secret_key):
    flag_int = flag_int * q + i

flag = long_to_bytes(flag_int)

print(f"{flag = }")>)

# flag = b'ictf{b4se_c0nv3rs1on_ftw_236680982d9e8449}\n'
```
## Flag:
`ictf{b4se_c0nv3rs1on_ftw_236680982d9e8449}`